《智能小车设计实验》总实验报告

小组成员：张旭阳、高佳愿
实验时间：2025年

================================================================================
目录
================================================================================

实验一 车模组装及电源稳压模块实现
实验二 循迹传感器模块的实现
实验三 驱动模块的实现
实验四 人机接口模块的实现
实验五 测速模块的实现

================================================================================
实验一 车模组装及电源稳压模块实现
================================================================================

一、实验目的

1. 掌握智能小车的组装流程，熟悉车模各部件的功能与连接方式。
2. 理解基于LM2940芯片的稳压电路原理，能够独立完成直流5V稳压模块的焊接与调试，为智能小车提供稳定电源。

二、实验器材

- 智能小车套件（含车架、电机、车轮、舵机等）
- LM2940稳压芯片
- 电解电容（10μF、100μF等规格）
- 电阻、导线、焊锡等焊接材料
- 万用表
- 直流电源（输入电压适配LM2940要求）
- Proteus或Altium Designer软件（用于绘制电路图）

三、分工情况

- 小组共2人，高佳愿负责车模机械部件的组装，张旭阳负责稳压电路的焊接与调试。

四、实验内容及步骤

1、组装车模

1. 拆开车模套件包装，识别车架、电机、车轮、舵机等部件。
2. 按照组装说明书，先将电机固定在车架指定位置，再安装车轮，确保车轮与电机轴连接牢固。
3. 安装舵机（若有转向需求），连接舵机与车架的转向机构。
4. 初步检查车模机械结构的稳定性，确保电机、车轮等运转时无卡顿。

2、分析理解电路原理、实现直流5V输出（使用proteus或AD绘制电路图）

（1）LM2940稳压电路原理分析

LM2940是一款低压差线性稳压器，能够将输入的直流电压稳定输出为5V。其工作时，通过内部的反馈调节机制，使输出电压保持稳定，不受输入电压小范围波动和负载变化的影响。在电路中，通常需要在输入端和输出端分别并联电解电容，以滤除电压中的纹波，提升输出电压的稳定性。

（2）电路图绘制（以Proteus为例）

1. 打开Proteus软件，在元件库中搜索并添加LM2940芯片、电解电容（输入侧选100μF，输出侧选10μF）、直流电源、接地符号等元件。
2. 按照电路连接规则，将直流电源正极连接到LM2940的输入端（Vin引脚），并在Vin与地之间并联100μF的电解电容；LM2940的输出端（Vout引脚）连接到负载（或实验用的测试点），并在Vout与地之间并联10μF的电解电容；LM2940的使能端（若有，根据具体型号确定，部分LM2940可直接使能）按要求连接。
3. 绘制完成后，进行电路的电气规则检查，确保无短路、开路等错误。

（3）稳压电路焊接与调试

1. 准备焊接工具（电烙铁、焊锡丝、镊子等），并将电烙铁预热至合适温度。
2. 按照绘制的电路图，依次将LM2940芯片、电解电容、导线等焊接到电路板上，注意电解电容的正负极性（长脚为正，短脚为负，需与电路中的正负极对应）。
3. 焊接完成后，使用万用表检查电路的通断情况，重点检查LM2940的引脚连接、电解电容的极性是否正确，确保无短路。
4. 接通直流输入电源（输入电压需在LM2940的输入电压范围内，如7V-20V），使用万用表的电压档测量LM2940的输出端电压，观察是否稳定在5V左右。若电压偏离，检查电路连接、元件焊接是否有误，必要时重新焊接或更换元件。

五、实验结果

1、车模组装结果

成功完成智能小车的机械部件组装，车架结构稳定，电机与车轮连接牢固，手动转动车轮时电机运转正常，车模能够在平面上平稳移动，机械部分组装符合实验要求。

2、电路实现结果

- 电路图绘制：在Proteus中成功绘制出基于LM2940的5V稳压电路图，电路元件连接正确，通过电气规则检查。
- 焊接与调试：稳压电路焊接完成后，经万用表检测，输入电压为12V时，输出电压稳定在5.0V，满足直流5V输出要求，电路工作正常。

六、实验总结

1、小组总结

本次实验中，小组成员分工明确、协作良好。在车模组装环节，高佳愿高效完成了机械结构的搭建；电路设计与焊接环节，张旭阳配合默契，顺利完成了LM2940稳压电路的原理分析、电路图绘制与焊接调试。通过本次实验，小组成员不仅掌握了智能小车的组装技巧，还深入理解了线性稳压器的工作原理，提升了电路焊接与调试的实践能力。同时，也认识到在实验过程中，细节把控至关重要，如电解电容的极性、芯片引脚的连接等，稍有疏忽便会导致实验故障，需严谨对待每一个步骤。

思考题

1、LM2940芯片资料（包括引脚图、输入电压范围等）

- 引脚功能：LM2940通常为TO-220封装，以LM2940-5.0为例，引脚1为Vin（输入电压端），引脚2为GND（接地端），引脚3为Vout（输出电压端，输出稳定5.0V）。
- 输入电压范围：典型输入电压范围为7V至20V，需保证输入电压比输出电压至少高2V（压差），以确保稳压器正常工作。
- 输出电流：最大输出电流可达1A，能够满足多数小型电子设备（如智能小车的控制电路、传感器等）的供电需求。

2、电路中电解电容的作用是什么？其容值大致范围是多少？

- 作用：在LM2940稳压电路中，电解电容主要起到滤波作用。输入侧的电解电容用于滤除输入电压中的纹波和噪声，使输入到LM2940的电压更加平滑；输出侧的电解电容用于进一步滤除输出电压的纹波，同时可以改善负载突变时的瞬态响应，提升输出电压的稳定性。
- 容值范围：输入侧的电解电容容值通常在100μF左右，输出侧的电解电容容值通常在10μF左右。实际应用中，可根据输入电压的纹波情况和负载要求适当调整容值，如输入电压纹波较大时，可增大输入侧电容容值；负载对电压稳定性要求较高时，可增大输出侧电容容值。

================================================================================
实验二 循迹传感器模块的实现
================================================================================

一、实验目的

1. 掌握红外循迹传感器的工作原理及其在智能小车中的应用。
2. 学习通过单片机读取传感器信号，实现智能小车的循迹功能。
3. 理解传感器与单片机的接口设计方法，掌握数字信号的处理与判断。
4. 熟悉循迹算法的设计与实现，能够编写程序实现基本的循迹控制。

二、实验器材

- STC89C52RC单片机核心板 × 1
- 红外循迹传感器模块（TCRT5000） × 3-5个
- 智能小车底盘 × 1
- 10kΩ电阻 × 若干
- 杜邦线若干（公母头、母母头）
- 可调直流电源（5V） × 1
- 万用表 × 1
- 计算机（安装Keil、Proteus开发环境）
- 黑色电工胶带（用于制作循迹轨道）

三、分工情况

- 张旭阳：负责传感器电路搭建与硬件连接，Proteus仿真电路设计。
- 高佳愿：负责程序编写与调试，循迹算法设计与优化，实验报告撰写。

四、实验内容及步骤

1. 软件仿真（过程描述）

（1）仿真平台搭建
- 在Proteus中创建新工程，选取STC89C52RC单片机、TCRT5000红外传感器模型、LED指示灯等关键元件。
- 配置电源模块，设置合适的电压参数（5V逻辑电源）。
- 搭建传感器信号输入电路，模拟传感器输出信号。

（2）传感器信号仿真测试
- 编写程序实现传感器信号的读取与处理。
- 通过仿真环境模拟不同地面情况（白色地面、黑色轨道），观察传感器输出信号的变化。
- 测试多个传感器的协同工作，验证循迹逻辑的正确性。

（3）循迹算法仿真
- 设计基本的循迹算法：当传感器检测到黑线时输出低电平，检测到白色地面时输出高电平。
- 实现多传感器循迹逻辑：根据传感器阵列的状态判断小车位置，控制小车转向。
- 仿真测试小车在不同轨道情况下的循迹性能。

2. 分析理解循迹传感器模块的原理和作用，说明传感器模块与单片机的引脚连接关系

（1）TCRT5000红外循迹传感器工作原理

TCRT5000是一种反射式红外光电传感器，由红外发射管和红外接收管组成。其工作原理如下：
- 红外发射管发出红外光，照射到地面。
- 红外接收管接收反射回来的红外光。
- 当传感器位于白色地面上时，反射光较强，接收管导通，输出低电平（或高电平，取决于电路设计）。
- 当传感器位于黑色轨道上时，反射光较弱，接收管截止，输出高电平（或低电平）。

（2）传感器模块的作用

- 检测地面颜色：通过检测反射光的强度，判断传感器下方是白色地面还是黑色轨道。
- 提供位置信息：多个传感器组成传感器阵列，可以判断小车相对于轨道的相对位置。
- 实现循迹控制：根据传感器阵列的输出信号，控制小车的转向和速度，使小车沿着黑色轨道行驶。

（3）传感器模块与单片机的引脚连接关系

- 传感器1输出端 → 单片机P3.2（INT0外部中断引脚，或普通I/O口）
- 传感器2输出端 → 单片机P3.3（INT1外部中断引脚，或普通I/O口）
- 传感器3输出端 → 单片机P3.4（普通I/O口）
- 传感器4输出端 → 单片机P3.5（普通I/O口）
- 传感器5输出端 → 单片机P3.6（普通I/O口）
- 传感器模块VCC → +5V电源
- 传感器模块GND → 共同接地端

（4）传感器阵列布局

典型的五传感器阵列布局（从左到右）：
- 传感器1：最左侧传感器
- 传感器2：左侧传感器
- 传感器3：中间传感器
- 传感器4：右侧传感器
- 传感器5：最右侧传感器

五、实验结果

1. 软件仿真结果

- 传感器信号读取：在Proteus仿真中，成功读取各传感器的输出信号，当模拟黑线经过传感器下方时，传感器输出信号正确变化。
- 循迹算法验证：仿真测试中，小车能够根据传感器阵列的状态正确判断位置，并执行相应的转向控制。
- 多传感器协同：多个传感器协同工作正常，能够准确检测轨道位置。

2. 电路实现结果

- 传感器安装：成功将5个TCRT5000传感器安装在小车前端，传感器间距约2cm，传感器高度距离地面约1-2cm。
- 信号检测：实际测试中，传感器能够准确区分白色地面和黑色轨道，输出信号稳定可靠。
- 循迹功能：小车能够沿着黑色轨道行驶，当偏离轨道时能够及时调整方向，循迹效果良好。

六、实验总结

1. 小组总结

本次实验成功实现了基于TCRT5000红外传感器的智能小车循迹功能。在实验过程中，团队成员密切配合，从传感器原理学习、电路搭建到程序编写与调试，系统掌握了循迹传感器的工作原理和应用方法。

通过本次实验，我们深入理解了反射式红外传感器的工作原理，掌握了传感器与单片机的接口设计方法，学会了循迹算法的设计与实现。在调试过程中，我们发现传感器的高度和灵敏度调节对循迹效果有重要影响，通过反复调试找到了最佳参数。这次实践不仅提升了我们的硬件调试能力，也增强了我们解决实际工程问题的能力。

2. 个人总结

- 张旭阳：在本次实验中，我主要负责传感器电路的搭建和硬件连接。通过实际动手操作，我对TCRT5000传感器的引脚功能、工作特性有了直观的认识。在调试过程中，我学会了如何调节传感器的灵敏度，如何优化传感器的安装位置和高度。这次实验让我深刻体会到硬件调试需要耐心和细致，每一个细节都可能影响最终效果。

- 高佳愿：我主要负责程序编写和循迹算法的设计。在编写程序时，我深入理解了传感器信号的读取与处理逻辑，学会了如何根据传感器阵列的状态判断小车位置。通过不断调试和优化算法，我解决了传感器响应延迟、小车转向过度等问题，提升了编程和调试能力。同时，也认识到算法设计需要结合实际硬件特性，只有软硬件紧密结合，才能实现良好的循迹效果。

思考题

1. 源程序（有详细注释）

```c
#include <reg52.h>

// 传感器引脚定义
sbit SENSOR1 = P3^2;  // 最左侧传感器
sbit SENSOR2 = P3^3;  // 左侧传感器
sbit SENSOR3 = P3^4;  // 中间传感器
sbit SENSOR4 = P3^5;  // 右侧传感器
sbit SENSOR5 = P3^6;  // 最右侧传感器

// 电机控制引脚定义（假设使用P1口控制L298N）
sbit MOTOR1_PIN1 = P1^0;  // 左电机控制1
sbit MOTOR1_PIN2 = P1^1;  // 左电机控制2
sbit MOTOR2_PIN1 = P1^2;  // 右电机控制1
sbit MOTOR2_PIN2 = P1^3;  // 右电机控制2

// 延时函数
void Delay_ms(unsigned int ms)
{
    unsigned int i, j;
    for(i = 0; i < ms; i++)
        for(j = 0; j < 113; j++);
}

// 读取传感器状态函数
unsigned char Read_Sensors()
{
    unsigned char sensor_state = 0;
    
    // 读取5个传感器的状态，0表示检测到黑线，1表示检测到白色地面
    if(SENSOR1 == 0) sensor_state |= 0x01;  // 最左侧传感器
    if(SENSOR2 == 0) sensor_state |= 0x02;  // 左侧传感器
    if(SENSOR3 == 0) sensor_state |= 0x04;  // 中间传感器
    if(SENSOR4 == 0) sensor_state |= 0x08;  // 右侧传感器
    if(SENSOR5 == 0) sensor_state |= 0x10;  // 最右侧传感器
    
    return sensor_state;
}

// 循迹控制函数
void Track_Control()
{
    unsigned char sensor_state = Read_Sensors();
    
    // 根据传感器状态控制小车运动
    switch(sensor_state)
    {
        case 0x04:  // 只有中间传感器检测到黑线，直行
            MOTOR1_PIN1 = 1;
            MOTOR1_PIN2 = 0;
            MOTOR2_PIN1 = 1;
            MOTOR2_PIN2 = 0;
            break;
            
        case 0x02:  // 左侧传感器检测到黑线，左转
        case 0x01:
            MOTOR1_PIN1 = 0;
            MOTOR1_PIN2 = 0;
            MOTOR2_PIN1 = 1;
            MOTOR2_PIN2 = 0;
            break;
            
        case 0x08:  // 右侧传感器检测到黑线，右转
        case 0x10:
            MOTOR1_PIN1 = 1;
            MOTOR1_PIN2 = 0;
            MOTOR2_PIN1 = 0;
            MOTOR2_PIN2 = 0;
            break;
            
        case 0x00:  // 所有传感器都检测到黑线，可能是十字路口，直行
        case 0x1F:  // 所有传感器都检测到白色，可能偏离轨道，停止或搜索
        default:
            MOTOR1_PIN1 = 0;
            MOTOR1_PIN2 = 0;
            MOTOR2_PIN1 = 0;
            MOTOR2_PIN2 = 0;
            break;
    }
}

// 主函数
void main()
{
    while(1)
    {
        Track_Control();  // 执行循迹控制
        Delay_ms(10);     // 延时，控制循迹响应速度
    }
}
```

2. 简述TCRT5000传感器的工作原理（结合源程序）

TCRT5000是一种反射式红外光电传感器，由红外发射管和红外接收管组成。其工作原理如下：

- 红外发射管发出红外光，照射到地面。
- 红外接收管接收反射回来的红外光。
- 当传感器位于白色地面上时，反射光较强，接收管导通，输出低电平（在源程序中，SENSORx == 0表示检测到黑线，这取决于具体的电路设计，有些电路设计是反相的）。
- 当传感器位于黑色轨道上时，反射光较弱，接收管截止，输出高电平。

在源程序中，通过读取P3口的各个引脚状态来判断传感器是否检测到黑线。当传感器检测到黑线时，对应的引脚为低电平（0），程序通过位操作将传感器状态组合成一个字节，然后根据不同的传感器状态组合，控制小车的运动方向。

3. 简述循迹算法的设计思路（结合源程序）

循迹算法的设计思路是根据传感器阵列的状态来判断小车相对于轨道的位置，然后控制小车转向，使小车始终沿着轨道行驶。

在源程序中，循迹算法的实现如下：

- 读取传感器状态：通过Read_Sensors()函数读取5个传感器的状态，将状态组合成一个字节。
- 判断位置：根据传感器状态判断小车位置：
  - 只有中间传感器检测到黑线（0x04）：小车在轨道中央，直行。
  - 左侧传感器检测到黑线（0x02或0x01）：小车偏右，需要左转。
  - 右侧传感器检测到黑线（0x08或0x10）：小车偏左，需要右转。
  - 所有传感器都检测到黑线（0x00）：可能是十字路口，直行。
  - 所有传感器都检测到白色（0x1F）：可能偏离轨道，停止。
- 控制运动：根据判断结果，控制左右电机的转向，实现小车的转向控制。

4. TCRT5000传感器的说明资料（包括引脚图等）

TCRT5000红外反射式传感器技术规格：

（1）引脚功能
- 引脚1：红外发射管正极（Anode）
- 引脚2：红外发射管负极（Cathode）
- 引脚3：红外接收管集电极（Collector）
- 引脚4：红外接收管发射极（Emitter）

（2）主要特性
- 工作电压：3.3V - 5V
- 工作电流：典型值20mA
- 检测距离：1mm - 25mm（可调）
- 响应时间：< 10μs
- 工作温度：-25°C ~ +85°C

（3）应用说明
- 检测距离可通过调节传感器高度或灵敏度电位器来调整。
- 传感器对环境的适应性较好，但在强光环境下可能受到影响。
- 建议传感器距离地面1-2cm，以获得最佳的检测效果。

================================================================================
实验三 驱动模块的实现
================================================================================

一、实验目的
掌握电机驱动模块的基本工作原理及其在智能车控制系统中的应用
学习通过单片机控制直流电机实现正转、反转及多级调速的方法
熟悉电机驱动电路的仿真设计与实际调试流程
掌握智能小车基本运动控制与路径规划的实现方法

二、实验器材
L298N电机驱动模块 × 1
STC89C52RC单片机核心板 × 1
直流减速电机 × 2
智能小车底盘 × 1
两位拨码开关 × 1
10kΩ电阻 × 3
杜邦线若干（公母头2根；母母头6根）
可调直流电源（7-12V） × 1
万用表× 1
计算机（安装Keil、Proteus开发环境）

三、分工情况
成员	主要职责 
张旭阳   电路搭建
高佳愿   软件开发

四、实验内容及步骤
1. 软件仿真（过程描述）
仿真平台搭建
在Proteus中创建新工程，选取单片机、L298N驱动芯片、直流电机模型等关键元件
配置电源模块，设置合适的电压参数
电路连接配置
将单片机P1.0-P1.3端口连接至L298N的IN1-IN4输入引脚
单片机P1.4-P1.5端口连接至ENA、ENB使能端，用于PWM调速
搭建拨码开关控制电路，实现运行模式选择
运动仿真测试
基础运动测试：编写程序实现电机正反转控制，验证驱动电路功能
多速级测试：通过调节PWM占空比，实现高、中、低三档速度控制
路径规划测试：设计正方形轨迹程序，测试小车循迹性能

2. 分析理解驱动模块的原理和作用，说明驱动模块与电机、单片机的引脚连接关系
驱动模块工作原理
L298N是双H桥电机驱动芯片，内部包含两个完整的H桥电路。每个H桥通过控制输入信号的逻辑组合，实现电机的正转、反转和制动功能。使能端接收PWM信号，通过调节占空比实现电机转速控制。
模块核心功能
提供电机所需的大电流驱动能力
实现电机的双向旋转控制
支持PWM调速功能
具备过热保护和抗干扰能力
系统连接关系
驱动模块与单片机：

IN1、IN2 → P1.0、P1.1（控制电机A转向）
IN3、IN4 → P1.2、P1.3（控制电机B转向）
ENA、ENB → P1.4、P1.5（PWM调速信号）
驱动模块与电机：
OUT1、OUT2 → 直流电机A
OUT3、OUT4 → 直流电机B
电源连接：
VCC → +5V逻辑电源
VS → +7V~+12V电机电源
GND → 共同接地端

五、实验结果
1. 软件仿真结果
成功实现小车前进、后退基本运动仿真，电机响应准确无误
三档速度调节功能正常，速度变化明显且过渡平稳
正方形路径跟踪准确，转弯角度控制精确，轨迹符合预期

2. 电路实现结果
基础运动测试：开关闭合后，电源指示灯正常点亮。小车准确执行前进5秒、暂停1秒、后退5秒的预设动作序列
直线行驶性能：通过精细调节双电机PWM参数，小车直线行驶稳定性良好，偏移量在可接受范围内
多速级路径跟踪：小车成功以三种不同速度完成正方形路径行驶，各档位速度区分明显，转弯动作协调

六、实验总结
1. 小组总结
通过本次实验，我们成功构建了基于L298N的智能小车驱动系统。在实验过程中，团队成员密切配合，从理论分析、仿真设计到实物调试，系统掌握了电机驱动技术的核心要点。特别是在解决电机同步性问题时，通过软件补偿的方法有效改善了小车的直线行驶性能。这次实践不仅加深了我们对电机驱动原理的理解，也提升了解决实际工程问题的能力。

2. 个人总结

思考题：
1. 源程序（有详细注释）
#include <reg52.h>
sbit MOTOR1_PIN1 = P1^2;
sbit MOTOR1_PIN2 = P1^3;
sbit MOTOR2_PIN1 = P1^4;
sbit MOTOR2_PIN2 = P1^5;

void Delay_ms(unsigned int milliseconds) {
unsigned int i, j;
for (i = 0; i < milliseconds; i++) {
for (j = 0; j < 113; j++); 
}
}

void main(void) {
while (1) {

MOTOR1_PIN1 = 1;
MOTOR1_PIN2 = 0;
MOTOR2_PIN1 = 1;
MOTOR2_PIN2 = 0;
Delay_ms(5000); 

MOTOR1_PIN1 = 0;
MOTOR1_PIN2 = 0;
MOTOR2_PIN1 = 0;
MOTOR2_PIN2 = 0;
Delay_ms(300); 

MOTOR1_PIN1 = 0;
MOTOR1_PIN2 = 1;
MOTOR2_PIN1 = 0;
MOTOR2_PIN2 = 1;
Delay_ms(5000);

MOTOR1_PIN1 = 0;
MOTOR1_PIN2 = 0;
MOTOR2_PIN1 = 0;
MOTOR2_PIN2 = 0;
Delay_ms(300);
}
}

2. 简述直流电机的调速原理？（结合源程序）
直流电机的转速主要由电源电压和电枢电流决定。调速的常见方法有变电源电压、调节电枢回路电阻、采用脉宽调制（PWM）等方式。在实际应用中，常通过控制电机两端的电压极性和通断，实现电机的正反转和启停，从而达到调速和控制方向的目的。
程序实现方式：
通过控制单片机的I/O口（P1.2 ~ P1.5）与电机驱动电路（如H桥）连接，控制两个直流电机的正反转和启停。MOTORx_PINy = 1 或 0 控制电机的端口电平，实现电机的不同工作状态：正转（如 MOTOR1_PIN1=1, MOTOR1_PIN2=0）反转（如 MOTOR1_PIN1=0, MOTOR1_PIN2=1）停止（如两个引脚都为0）Delay_ms() 函数用于控制电机动作的持续时间，从而间接影响电机的运行时间和速度表现。

3. 驱动模块的说明资料
L298N电机驱动模块技术规格
核心架构：双H桥直流电机驱动电路
工作电压范围：
驱动电源（VS）：+5V ~ +35V
逻辑电源（VCC）：+5V ~ +7V
输出性能：
单桥持续输出电流：2A
峰值输出电流：3A
最大输出功率：25W
控制特性：
支持两个直流电机或一个两相步进电机
独立的使能控制端
逻辑电平兼容TTL/CMOS
保护功能：
内置过热自动关断保护
防止电源反接保护
低压误操作保护
接口定义：
电机输出：OUT1/OUT2（通道A）、OUT3/OUT4（通道B）
逻辑输入：IN1-IN4（方向控制）、ENA/ENB（使能控制）
电源接口：VCC（逻辑）、VS（驱动）、GND（地）

================================================================================
实验四 人机接口模块的实现
================================================================================

《智能小车设计实验》报告（实验四 人机接口模块的实现）
一、实验目的
1. 掌握AT89C52单片机与数码管、按键的接口设计方法。
2. 实现数码管静态显示数字"21"以及按键加一功能，理解人机接口模块的工作原理。
3. 深入理解共阳、共阴数码管的区别，以及数码管段选、位选的概念和应用。

二、实验器材
- AT89C52单片机开发板
- 两位共阳数码管
- 按键开关
- 电阻、三极管（如9012）
- 面包板、杜邦线等
- Keil uVision软件（用于程序编写与仿真）
- Proteus软件（用于电路仿真）

三、分工情况
- 高佳愿：负责电路硬件连接、Proteus仿真电路搭建以及数码管与单片机引脚连接关系的图文整理。
- 张旭阳：负责程序编写、注释以及实验结果的测试与分析，完成实验总结部分。

四、实验内容及步骤
1. 软件仿真（过程描述）
（1）静态显示数字"21"
- 打开Proteus软件，搭建包含AT89C52单片机、两位共阳数码管的仿真电路。数码管的段选端连接到单片机的P0口，位选端通过三极管分别连接到P2.0和P2.1口。
- 打开Keil uVision软件，编写程序，定义数码管段码（共阳），对于数字"2"，段码为`0xA4`；数字"1"，段码为`0xF9`。通过P0口输出段码，P2.0置低、P2.1置高，使个位显示"1"；P2.0置高、P2.1置低，使十位显示"2"，由于静态显示是持续保持该状态，所以在程序中可通过循环保持输出。
- 将程序编译生成HEX文件，加载到Proteus仿真电路的AT89C52单片机中，运行仿真，观察数码管是否稳定显示"21"。

（2）数码管按键加一
- 在仿真电路中添加按键，将按键一端接地，另一端通过上拉电阻连接到单片机的某一I/O口（如P3.0）。
- 编写程序，在静态显示"21"的基础上，检测按键是否按下。当按键按下时，对显示的数值进行加一操作，然后更新数码管的段码输出，实现数值递增显示。

2. 数码管与单片机的引脚连接关系（图文并茂）
（1）电路连接图
- 两位共阳数码管的8个段选端（a、b、c、d、e、f、g、dp）分别对应连接到AT89C52单片机的P0.0~P0.7口。
- 数码管的个位公共端（共阳端）通过NPN三极管（如9013）的集电极连接到+5V电源，三极管的基极通过限流电阻连接到单片机的P2.0口；十位公共端通过另一个NPN三极管的集电极连接到+5V电源，三极管基极通过限流电阻连接到单片机的P2.1口。
- 按键一端接地，另一端通过上拉电阻连接到单片机的P3.0口。

（2）引脚连接说明
- **段选端**：P0口作为段选控制，用于输出数码管的段码，控制每个段的亮灭，从而显示不同数字。
- **位选端**：P2.0和P2.1通过三极管控制数码管的个位和十位的公共端，实现对某一位数码管的选通。
- **按键端**：P3.0用于检测按键输入，实现按键加一的功能触发。

五、实验结果
1. 软件仿真结果
- 静态显示"21"：在Proteus仿真中，数码管稳定显示数字"21"，十位为"2"、个位为"1"，无闪烁现象，表明段选和位选控制正确。
- 数码管按键加一：当按下按键时，显示的数值从"21"开始依次递增，如"22"、"23"等，每次按键操作数值准确加一，仿真过程中功能实现正常。

2. 电路实现结果
- 静态显示"21"：在实际硬件电路中，数码管清晰显示"21"，显示稳定，说明硬件连接和程序逻辑正确。
- 数码管按键加一：按下按键后，数码管显示的数值能够依次加一，按键响应灵敏，功能实现符合预期。

六、实验总结
1. 小组总结
本次实验围绕人机接口模块的实现，成功完成了数码管静态显示"21"和按键加一功能。在实验过程中，小组成员分工明确，高佳愿同学在硬件电路搭建和图文整理方面表现出色，确保了电路连接的准确性和资料的完整性；张旭阳同学在程序编写和功能测试上投入较多，保证了程序的正确性和功能的实现。

通过本次实验，我们深入理解了AT89C52单片机与数码管、按键的接口原理，掌握了共阳数码管的段选、位选控制方法，以及按键输入的检测方式。同时，在软硬件联调过程中，我们也积累了排查问题的经验，比如在仿真中遇到数码管显示异常时，通过检查段码定义和位选控制逻辑，快速解决了问题。

2. 个人总结
- **高佳愿**：在本次实验中，我主要负责硬件部分和图文资料的整理。通过搭建实际电路和仿真电路，我对数码管的引脚分布、与单片机的连接方式有了直观的认识。在整理图文时，也锻炼了自己的绘图和总结能力。在实验过程中，我意识到硬件连接的细节非常重要，比如三极管的极性、电阻的阻值选择等，稍有不慎就会导致电路功能异常，这让我在后续的硬件操作中更加谨慎。
- **张旭阳**：我主要负责程序编写和功能测试。在编写程序时，对共阳数码管的段码定义、位选控制以及按键检测的逻辑有了深入理解。通过不断调试程序，解决了数码管显示错误、按键响应不灵敏等问题，提升了自己的编程和调试能力。同时，也深刻体会到理论知识与实际应用的结合，只有将单片机原理、数码管工作原理等理论知识吃透，才能顺利完成实验功能的实现。

思考题
1. 源程序（有详细注释）
```c
#include <reg52.h>

// 定义数码管段码（共阳），0-9的段码
unsigned char code seg_code[] = {0xC0, 0xF9, 0xA4, 0xB0, 0x99, 
                                 0x92, 0x82, 0xF8, 0x80, 0x90};
unsigned char num = 21; // 初始显示数值
sbit key = P3^0;        // 按键引脚
sbit bit1 = P2^0;      // 个位数码管位选
sbit bit2 = P2^1;       // 十位数码管位选

void delay(unsigned int t) {
    unsigned int i, j;
    for(i = t; i > 0; i--)
        for(j = 1275; j > 0; j--);
}

void display() {
    unsigned char ge, shi;
    ge = num % 10;  // 取个位
    shi = num / 10; // 取十位
    
    // 显示十位
    P0 = seg_code[shi];
    bit2 = 0;
    bit1 = 1;
    delay(1);
    
    // 显示个位
    P0 = seg_code[ge];
    bit1 = 0;
    bit2 = 1;
    delay(1);
}

void key_scan() {
    if(key == 0) {  // 按键按下
        delay(10);  // 消抖
        if(key == 0) {
            num++;  // 数值加一
            while(!key); // 等待按键释放
        }
    }
}

void main() {
    while(1) {
        display();
        key_scan();
    }
}
```

2. 简述共阳数码管和共阴数码管的区别？什么是数码管的段选和位选（结合源程序）
- **共阳数码管和共阴数码管的区别**
  - 共阳数码管：公共端为阳极（接+5V），段选端为阴极，当某一段的段选端为低电平时，该段点亮。例如在源程序中，段码`seg_code`的定义就是基于共阳数码管，如数字"0"的段码是`0xC0`（即对应段a、b、c、d、e、f亮，g灭）。
  - 共阴数码管：公共端为阴极（接地），段选端为阳极，当某一段的段选端为高电平时，该段点亮。其段码与共阳数码管相反，若将源程序中的段码取反，即可适用于共阴数码管。

- **数码管的段选和位选**
  段选：控制数码管的各个段（a、b、c、d、e、f、g、dp）的亮灭，从而显示不同的数字。在源程序中，通过`P0`口输出段码`seg_code[shi]`和`seg_code[ge]`来实现段选，例如显示十位数字时，`P0 = seg_code[shi]`就是将十位对应的段码输出到段选端。
  位选：控制多位数码管中某一位的选通，即决定哪一位数码管显示内容。在源程序中，通过`bit1`（P2^0）和`bit2`（P2^1）来控制个位和十位数码管的选通，如`bit2 = 0; bit1 = 1;`是选通十位数码管，使其显示十位数字。

3. 简述连接在数码管位选端的三极管在电路中的作用
连接在数码管位选端的三极管主要起到**电流放大**和**开关控制**的作用。
- 由于数码管的工作电流较大，单片机I/O口的驱动能力有限，无法直接提供足够的电流使数码管正常发光。三极管可以将单片机I/O口的小电流放大，提供数码管所需的较大电流，保证数码管能够正常点亮。
- 同时，三极管作为开关使用，当单片机位选端输出高电平时，三极管导通，数码管的公共端获得相应的电压（共阳数码管为+5V），该位数码管被选通；当单片机位选端输出低电平时，三极管截止，该位数码管关闭，从而实现对不同位数码管的选通控制。

4. 两位共阳数码管的说明资料（包括引脚图等）
（1）引脚分布
两位共阳数码管通常有10个引脚，其中：
- 8个引脚为段选端，分别对应a、b、c、d、e、f、g、dp段，用于控制各段的亮灭。
- 另外2个引脚为位选端，分别是个位公共端和十位公共端（均为阳极）。

以常见的两位共阳数码管为例，其引脚排列（从正面看，引脚向下）如下：
| 引脚序号 | 功能   | 引脚序号 | 功能   |
|----------|--------|----------|--------|
| 1        | e段    | 6        | dp段   |
| 2        | d段    | 7        | 十位公共端（阳极） |
| 3        | c段    | 8        | g段    |
| 4        | 个位公共端（阳极） | 9        | f段    |
| 5        | b段    | 10       | a段    |

（2）引脚功能说明
段选引脚（a、b、c、d、e、f、g、dp）**：与单片机I/O口连接，输入相应的段码电平，控制各段的亮灭，从而组合显示不同的数字或字符。
位选引脚（个位公共端、十位公共端）**：连接到三极管的集电极，通过单片机控制三极管的导通与截止，实现对个位或十位数码管的选通。

================================================================================
实验五 测速模块的实现
================================================================================

实验五 测速模块的实现
• 实验目的 
• 掌握测速模块的工作原理及应用方法。
• 学会使用单片机对脉冲信号进行计数与处理。
• 实现小车轮子转速与小车速度的测量与显示。
• 掌握软件仿真与硬件电路的结合调试方法。

• 实验器材 
单片机开发板：STC89C52
测速模块：霍尔传感器
直流电机与车轮
仿真软件Proteus
开发环境Keil4
其他
杜邦线、电源模块等

• 分工情况 
张旭阳：软件编程与仿真调试，多步进行流畅。
高佳愿：电路搭建与硬件测试，实验报告撰写与资料整理。

四、实验内容及步骤 
1、软件仿真（过程描述），包括对小车轮子转速测量及显示，小车速度的显示。 
在Proteus中搭建单片机最小系统、显示模块和测速传感器模型。
编写程序模拟脉冲输入，通过中断方式计数，计算转速并显示在LCD上。
仿真中设置不同频率的脉冲信号，验证转速与速度计算的正确性。

• 说明测速模块与单片机的引脚连接关系（图文并茂）。 
测速模块信号输出端接单片机外部中断引脚（如INT0/P3.2）。
电机驱动模块接P1口控制电机转动。

五、实验结果 
1、软件仿真结果 
成功在屏幕上显示轮子转速（单位：RPM）和小车速度（单位：cm/s）。
脉冲频率变化时，显示值相应变化，符合预期。

• 电路实现结果，包括小车速度测量及显示的实现情况。 
实际电路中，测速模块能稳定输出脉冲，单片机计数准确。
屏幕能显示速度，误差在允许范围内。

六、实验总结 
1、小组总结 
实验成果
通过本次实验，我们掌握了测速模块的使用方法，理解了脉冲计数与速度转换的原理。
调试问题及解决
软硬件结合调试中遇到显示不稳定问题，通过检查接线和优化程序得以解决。

2、个人总结 
张旭阳：加深了对中断处理和定时器使用的理解。
高佳愿：提高了电路搭建与故障排查能力。

思考题： 
• 源程序（有详细注释） 
#include <reg52.h>
#include <intrins.h>

#define uchar unsigned char
#define uint  unsigned int

// LCD接口定义
sbit LCD_RS = P2^0;
sbit LCD_RW = P2^1;
sbit LCD_EN = P2^2;

// 显示用字符串
uchar code txt_rpm[] = "RPM:";
uchar code txt_speed[] = "Speed:cm/s";

// 全局变量
uchar pulse_cnt = 0;
uint  motor_rpm = 0;
uint  line_speed = 0;

//---------------- LCD操作函数 ----------------//
void LCD_WriteCmd(uchar cmd)
{
    LCD_RS = 0;
    LCD_RW = 0;
    P0 = cmd;
    LCD_EN = 1;
    _nop_();
    LCD_EN = 0;
}

void LCD_WriteData(uchar dat)
{
    LCD_RS = 1;
    LCD_RW = 0;
    P0 = dat;
    LCD_EN = 1;
    _nop_();
    LCD_EN = 0;
}

void LCD_Init()
{
    LCD_WriteCmd(0x38);
    LCD_WriteCmd(0x0C);
    LCD_WriteCmd(0x06);
    LCD_WriteCmd(0x01);
}

void LCD_ShowStr(uchar line, uchar *str)
{
    uchar i = 0;
    if (line == 1)
        LCD_WriteCmd(0x80);
    else
        LCD_WriteCmd(0xC0);

    while (str[i] != '\0')
    {
        LCD_WriteData(str[i]);
        i++;
    }
}

void LCD_ShowNum(uint value, uchar pos)
{
    LCD_WriteCmd(0xC0 + pos);
    LCD_WriteData(value / 100 + '0');
    LCD_WriteData((value / 10) % 10 + '0');
    LCD_WriteData(value % 10 + '0');
}

//---------------- 定时器与中断配置 ----------------//
void Timer0_Config()
{
    TMOD = 0x01;
    TH0 = 0x3C;
    TL0 = 0xB0;
    EA = 1;
    ET0 = 1;
    TR0 = 1;
}

void ExtInt0_Config()
{
    IT0 = 1;
    EX0 = 1;
}

//---------------- 主函数 ----------------//
void main()
{
    LCD_Init();
    Timer0_Config();
    ExtInt0_Config();

    while (1)
    {
        LCD_ShowStr(1, txt_rpm);
        LCD_ShowStr(2, txt_speed);
        LCD_ShowNum(motor_rpm, 5);
        LCD_ShowNum(line_speed, 7);
    }
}

//---------------- 定时器中断 ----------------//
void Timer0_ISR(void) interrupt 1
{
    static uchar t_counter = 0;
    TH0 = 0x3C;
    TL0 = 0xB0;
    t_counter++;

    if (t_counter >= 20)   // 每秒统计一次
    {
        motor_rpm = pulse_cnt * 30;  // 转速计算（假设2脉冲/转）
        line_speed = (uint)((motor_rpm * 2 * 3.1416 * 3) / 60.0); // 半径3cm
        pulse_cnt = 0;
        t_counter = 0;
    }
}

//---------------- 外部中断0 ----------------//
void ExtInt0_ISR(void) interrupt 0
{
    pulse_cnt++;
}

2、简述如何利用单片机对脉冲进行计数（结合源程序） 
• 使用外部中断（如INT0）对测速模块输出的脉冲进行计数。
• 每产生一个脉冲，进入中断服务函数，计数变量count加1。
• 通过定时器定时（如1秒）读取count值，计算转速与速度

3、简述小车轮子转速与小车速度之间的转换关系式（结合源程序）
转速（RPM）与速度（cm/s）的转换公式为：
速度=转速×2πr/60其中r为轮子半径。
程序中：speed = rpm * 2 * 3.14 * 3 / 60假设轮子半径为3cm。

================================================================================
实验总结
================================================================================

通过本次《智能小车设计实验》的完整学习与实践，我们系统地掌握了智能小车从基础组装到功能实现的全部过程。从实验一的车模组装和电源稳压模块，到实验二的循迹传感器模块，再到实验三的驱动模块、实验四的人机接口模块，以及实验五的测速模块，每个实验都让我们深入理解了智能小车系统的各个组成部分。

在实验过程中，我们不仅掌握了硬件电路的设计与调试方法，也提升了软件编程和系统集成的能力。通过团队协作，我们学会了如何分工合作，如何解决实际问题，如何将理论知识应用到实际项目中。这些经验将对我们今后的学习和工作产生积极的影响。

本次实验让我们深刻认识到，一个完整的智能小车系统需要多个模块的协同工作，每个模块都有其独特的功能和重要性。只有深入理解每个模块的工作原理，才能设计出稳定可靠的系统。同时，软硬件的结合调试也是非常重要的，需要我们在实践中不断积累经验，提高解决问题的能力。

最后，感谢老师在实验过程中的悉心指导，感谢团队成员的通力合作，让我们能够顺利完成本次智能小车设计实验的所有内容。

================================================================================
报告结束
================================================================================

